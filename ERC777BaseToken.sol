// source code is the sole property of swissrealty.io
// do not reproduce for commercial or non-commercial purposes

pragma solidity ^0.5.3;

import { safeMath } from "./safeMath.sol";
import { ERC777Token } from "./ERC777Token.sol";
import { ERC777TokensSender } from "./ERC777TokensSender.sol";
import { ERC777TokensRecipient } from "./ERC777TokensRecipient.sol";
import { DataStorage } from "./DataStorage.sol";
import { ERC1820Client} from "./ERC1820/contracts/ERC1820Client.sol";


contract ERC777BaseToken is ERC777Token, ERC1820Client {
    using safeMath for uint256;

    string internal mName;
    string internal mSymbol;
    uint256 internal mGranularity;
    uint256 internal mTotalSupply;

    DataStorage DStorage;

    /* -- Constructor -- */
    //
    /// @notice Constructor to create a ReferenceToken
    constructor(
        address _dataStorageAddress) public {
        DStorage = DataStorage(_dataStorageAddress);
        setInterfaceImplementation("ERC777Token", address(this));
    }

    /* -- ERC777 Interface Implementation -- */
    //

    // RETURN FUNCTIONS (To be used with Storage contract calls)
    /// @return the name of the token
    function name() public view returns (string memory) {
        return DStorage.name();
    }

    /// @return the symbol of the token
     function symbol() public view returns (string memory) {
         return DStorage.symbol();
    }

    /// @return the granularity of the token
    function granularity() public view returns (uint256) {
        return DStorage.granularity();
    }

    /// @return the total supply of the token
    function totalSupply() public view returns (uint256) {
        return DStorage.totalSupply();
    }

    /// @notice Return the account balance of some account
    /// @param _tokenHolder Address for which the balance is returned
    /// @return the balance of `_tokenAddress`.
    function balanceOf(address _tokenHolder) public view returns (uint256) {
        return DStorage.balanceOf(_tokenHolder);
    }

    /// @notice Return the list of default operators
    /// @return the list of all the default operators
    function defaultOperators() public view returns (address[] memory) {
        return DStorage.defaultOperators();
    }

    /// @notice Authorize a third party `_operator` to manage (send) `msg.sender`'s tokens.
    /// @param _operator The operator that wants to be Authorized
    function authorizeOperator(address _operator) public {
        require(_operator != msg.sender, "You can't authorize your own address as an operator.");
        bool _status;
        if (DStorage.checkIsDefaultOperator(_operator)) {
            _status = false;
            DStorage.setRevokedOperator(_operator, msg.sender, _status);
        } else {
            _status = true;
            DStorage.setAuthorizedOperator(_operator, msg.sender, _status);
        }

        emit AuthorizedOperator(_operator, msg.sender);
    }

    /// @notice Revoke a third party `_operator`'s rights to manage (send) `msg.sender`'s tokens.
    /// @param _operator The operator that wants to be Revoked
    function revokeOperator(address _operator) public {
        require(_operator != msg.sender, "You can't revoke your own address.");
        bool _status;
        if (DStorage.checkIsDefaultOperator(_operator)) {
            _status = true;
            DStorage.setRevokedOperator(_operator, msg.sender, _status);
        } else {
            _status = false;
            DStorage.setAuthorizedOperator(_operator, msg.sender, _status);
        }

        emit RevokedOperator(_operator, msg.sender);
    }

    /// @notice Check whether the `_operator` address is allowed to manage the tokens held by `_tokenHolder` address.
    /// @param _operator address to check if it has the right to manage the tokens
    /// @param _tokenHolder address which holDStorage the tokens to be managed
    /// @return `true` if `_operator` is authorized for `_tokenHolder`
    function isOperatorFor(address _operator, address _tokenHolder) public view returns (bool) {
        return (_operator == _tokenHolder ||
            DStorage.checkAuthorized(_operator, _tokenHolder) ||
            (DStorage.checkIsDefaultOperator(_operator) && !DStorage.checkRevokedDefaultOperator(_operator, _tokenHolder))
        );
    }

    /// @notice Send `_amount` of tokens on behalf of the address `from` to the address `to`.
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be sent to the recipient
    /// @param _operatorData Data generated by the operator to be sent to the recipient
    function operatorSend(address _from, address _to, uint256 _amount, bytes memory _userData, bytes memory _operatorData) public {
        require(isOperatorFor(msg.sender, _from), "Your address is not an operator for this address.");
        doSend(msg.sender, _from, _to, _amount, _userData, _operatorData, true);
    }

    function burn(uint256 _amount, bytes memory _holderData) public {
        doBurn(msg.sender, msg.sender, _amount, _holderData, "");
    }

    function operatorBurn(address _tokenHolder, uint256 _amount, bytes memory _holderData, bytes memory _operatorData) public {
        require(isOperatorFor(msg.sender, _tokenHolder), "Your address is not an operator for this address.");
        doBurn(msg.sender, _tokenHolder, _amount, _holderData, _operatorData);
    }

    /* -- Helper Functions -- */
    //
    /// @notice Internal function that ensures `_amount` is multiple of the granularity
    /// @param _amount The quantity that want's to be checked
    function requireMultiple(uint256 _amount) internal view {
        require(_amount.div(DStorage.granularity()).mul(DStorage.granularity()) == _amount,"The amount is not a valid multiple.");
    }

    /// @notice Check whether an address is a regular address or not.
    /// @param _addr Address of the contract that has to be checked
    /// @return `true` if `_addr` is a regular address (not a contract)
    function isRegularAddress(address _addr) internal view returns(bool) {
        if (_addr == address(0)) {return false;}
        uint size;
        assembly {
            size := extcodesize(_addr)
        }
        return size == 0;
    }

    /// @notice Helper function actually performing the sending of tokens.
    /// @param _operator The address performing the send
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not
    ///  implementing `erc777_tokenHolder`.
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwarDStorage compatible ERC20 transfer
    ///  functions SHOULD set this parameter to `false`.
    function doSend(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes memory _userData,
        bytes memory _operatorData,
        bool _preventLocking
    )
        internal
    {
        requireMultiple(_amount);

        callSender(_operator, _from, _to, _amount, _userData, _operatorData);

        require(_to != address(0), "forbid sending to 0x0 (=burning)");
        require(DStorage.balanceOf(_from) >= _amount, "ensure enough fund DStorage");

        // sets the sender balance to balance - amount
        uint256 balanceSender = DStorage.balanceOf(_from);
        balanceSender = balanceSender.sub(_amount);
        DStorage.setBalance(_from, balanceSender);

        // sets the receiver balance to balance + amount
        uint256 balanceReceiver = DStorage.balanceOf(_to);
        balanceReceiver = balanceReceiver.add(_amount);
        DStorage.setBalance(_to, balanceReceiver);


        callRecipient(_operator, _from, _to, _amount, _userData, _operatorData, _preventLocking); //ask

        emit Sent(_operator, _from, _to, _amount, _userData, _operatorData);
    }

    /// @notice Helper function actually performing the burning of tokens.
    /// @param _operator The address performing the burn
    /// @param _tokenHolder The address holding the tokens being burn
    /// @param _amount The number of tokens to be burnt
    /// @param _holderData Data generated by the token holder
    /// @param _operatorData Data generated by the operator
    function doBurn(address _operator, address _tokenHolder, uint256 _amount, bytes memory _holderData, bytes memory _operatorData)
        internal
    {
        requireMultiple(_amount);
        require(balanceOf(_tokenHolder) >= _amount, "Not enough funds in the token holder wallet.");

        // set the balance of the burn account to balance - amount burned
        uint256 burnedBalance = DStorage.balanceOf(_tokenHolder);
        burnedBalance = burnedBalance.sub(_amount);
        DStorage.setBalance(_tokenHolder, burnedBalance);

        // discarDStorage the burned amount from the totalSupply
        uint256 newTotalSupply = totalSupply();
        newTotalSupply = newTotalSupply.sub(_amount);
        DStorage.setTotalSupply(newTotalSupply);

        callSender(_operator, _tokenHolder, address(0), _amount, _holderData, _operatorData);
        emit Burned(_operator, _tokenHolder, _amount, _holderData, _operatorData);
    }

    /// @notice Helper function that checks for ERC777TokensRecipient on the recipient and calls it.
    ///  May throw according to `_preventLocking`
    /// @param _operator The address performing the send or mint
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The number of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    /// @param _preventLocking `true` if you want this function to throw when tokens are sent to a contract not
    ///  implementing `ERC777TokensRecipient`.
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwarDStorage compatible ERC20 transfer
    ///  functions SHOULD set this parameter to `false`.
    function callRecipient(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes memory _userData,
        bytes memory _operatorData,
        bool _preventLocking
    )
        internal
    {
        address recipientImplementation = interfaceAddr(_to, "ERC777TokensRecipient");
        if (recipientImplementation != address(0)) {
            ERC777TokensRecipient(recipientImplementation).tokensReceived(
                _operator, _from, _to, _amount, _userData, _operatorData);
        } else if (_preventLocking) {
            require(isRegularAddress(_to), "Cannot send to contract without ERC777TokensRecipient");
        }


    }

    /// @notice Helper function that checks for ERC777TokensSender on the sender and calls it.
    ///  May throw according to `_preventLocking`
    /// @param _from The address holding the tokens being sent
    /// @param _to The address of the recipient
    /// @param _amount The amount of tokens to be sent
    /// @param _userData Data generated by the user to be passed to the recipient
    /// @param _operatorData Data generated by the operator to be passed to the recipient
    ///  implementing `ERC777TokensSender`.
    ///  ERC777 native Send functions MUST set this parameter to `true`, and backwarDStorage compatible ERC20 transfer
    ///  functions SHOULD set this parameter to `false`.
    function callSender(
        address _operator,
        address _from,
        address _to,
        uint256 _amount,
        bytes memory _userData,
        bytes memory _operatorData
    )
        internal
    {
         address senderImplementation = interfaceAddr(_from, "ERC777TokensSender");
        if (senderImplementation == address(0)) {return;}
        ERC777TokensSender(senderImplementation).tokensToSend(
            _operator, _from, _to, _amount, _userData, _operatorData);

    }

}
